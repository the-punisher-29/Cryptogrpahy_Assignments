import math, random
from math import gcd
from Crypto.Util.number import long_to_bytes, inverse

# ---------------------------------------------------------
# Given values (from the printed output)
# My private key: (N, d)
N = 21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771
d = 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097
e_my = 0x10001  # 65537

# Friend public keys – all using the same modulus N, but different small exponents:
friend_exponents = [106979, 108533, 69557, 97117, 103231]
# Their product is the total exponent used during encryption:
f = 1
for exp in friend_exponents:
    f *= exp

# Final ciphertext (after sequential friend encryption)
c = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
# ---------------------------------------------------------
# Step 1. Factorize N given e and d using the relation k = e*d - 1.
# We then compute φ(N) = (p-1)*(q-1).

def recover_factors(N, e, d):
    k = e * d - 1
    # Write k = 2^s * r with r odd.
    s = 0
    r = k
    while r % 2 == 0:
        r //= 2
        s += 1

    # Try small candidate bases for g.
    for g in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
        y = pow(g, r, N)
        if y == 1 or y == N-1:
            continue
        for i in range(1, s+1):
            x = pow(g, r * (2**i), N)
            if x == 1:
                # then factor = gcd(g^(r*2^(i-1)) - 1, N)
                candidate = gcd(pow(g, r * (2**(i-1)), N) - 1, N)
                if 1 < candidate < N:
                    p = candidate
                    q = N // p
                    return p, q
    return None, None

p, q = recover_factors(N, e_my, d)
if p is None or q is None:
    raise ValueError("Failed to factorize N given d and e!")

phi = (p - 1) * (q - 1)

# Step 2. Invert friend encryption.
# The combined effect of friend encryption is raising m to the power f mod N.
# So to recover m, compute f_inv such that m = c^(f_inv) mod N.
f_inv = inverse(f, phi)
m = pow(c, f_inv, N)
flag = long_to_bytes(m)

print("Recovered flag:", flag)